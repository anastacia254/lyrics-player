<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Animated Lyrics Player</title>
  <style>
    :root{
      --bg: #0f1724;
      --card: #0b1220;
      --muted: #9aa4b2;
      --accent: #7dd3fc;
      --highlight: #ffd166;
      --text: #e6eef7;
      --glass: rgba(255,255,255,0.04);
      --line-gap: 10px;
      --font-sans: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{height:100%;margin:0;font-family:var(--font-sans);background:linear-gradient(180deg,#071024 0%,var(--bg) 60%);color:var(--text);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}

    .wrap{
      max-width:900px;margin:40px auto;padding:28px;border-radius:16px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }

    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px}
    h1{font-size:20px;margin:0;color:var(--accent);letter-spacing:0.4px}
    p.subtitle{margin:0;color:var(--muted);font-size:13px}

    .controls{
      display:flex;gap:10px;align-items:center;
    }
    button{
      background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;color:var(--text);cursor:pointer;font-weight:600;
      transition:transform .12s ease, background .12s;
    }
    button:hover{transform:translateY(-2px)}
    button:active{transform:translateY(0)}

    label{font-size:13px;color:var(--muted);display:flex;align-items:center;gap:8px}
    input[type=range]{width:140px}

    .lyrics-area{padding:18px;background:rgba(255,255,255,0.02);border-radius:12px;min-height:380px;display:flex;flex-direction:column;gap:var(--line-gap);overflow:hidden;position:relative}

    .line{
      opacity:0; transform:translateY(12px);
      font-size:18px;line-height:1.35;color:var(--muted);
      transition: opacity .35s ease, transform .35s ease, color .2s ease;
      padding:6px 10px;border-radius:8px;
      word-break:break-word;
    }

    .line.current{
      opacity:1; transform:translateY(0); color:var(--text);
      background: linear-gradient(90deg, rgba(255,209,102,0.06), rgba(125,211,252,0.03));
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* subtle karaoke reveal effect (left-to-right) on the current line */
    .line.current .reveal{
      display:inline-block;
      position:relative;
      overflow:hidden;
      vertical-align:top;
    }
    .line.current .reveal::after{
      content:"";
      position:absolute; left:0; top:0; height:100%;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.04) 40%, rgba(255,255,255,0.06) 60%, transparent 100%);
      width:0%;
      pointer-events:none;
      transition: width linear;
    }

    /* small footer */
    .footer{display:flex;justify-content:space-between;align-items:center;margin-top:14px;color:var(--muted);font-size:13px}
    .settings{display:flex;gap:10px;align-items:center}

    /* responsive */
    @media (max-width:560px){
      .wrap{margin:18px;padding:16px}
      .lyrics-area{min-height:320px}
      .line{font-size:16px}
      input[type=range]{width:110px}
    }
  </style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Animated lyrics player">
    <header>
      <div>
        <h1>Animated Lyrics</h1>
        <p class="subtitle">Lines appear automatically — use controls to play/pause or speed up.</p>
      </div>
      <div class="controls">
        <button id="playBtn" title="Play">▶ Play</button>
        <button id="pauseBtn" title="Pause">⏸ Pause</button>
        <label title="Speed">
          Speed
          <input id="speed" type="range" min="0.25" max="3" step="0.05" value="1" />
        </label>
      </div>
    </header>

    <main>
      <section class="lyrics-area" id="lyricsArea" aria-live="polite">
        <!-- lines will be injected here by JavaScript -->
      </section>

      <div class="footer">
        <div class="settings">Current animation duration per line: <span id="durationDisplay">1.2s</span></div>
        <div>Tip: You can add <code>data-duration</code> (ms) to any line to override the default.</div>
      </div>
    </main>
  </div>

  <script>
    // === LYRICS: paste or edit the lyrics array below ===
    // Each element is an object { text: "...", duration: optionalNumberInMs }
    const lyrics = [
{ text: "Mind over matter" },
{ text: "Does it matter to any of us?" },
{ text: "Don't change the subject" },
{ text: "I'm heavy on your love" },
{ text: "I missed that train" },
{ text: "New York City, it rains" },
{ text: "Fly to East L.A. in big jet planes" },
{ text: "You know you're on my mind?" },
{ text: "And if the world don't break" },
{ text: "I'll be shaking it" },
{ text: "'Cause I'm a young man after all" },
{ text: "And when the seasons change" },
{ text: "Will you stand by me?" },
{ text: "'Cause I'm a young man built to fall" },
{ text: "Mind over matter" },
{ text: "I'm in tatters thinking 'bout her" },
{ text: "Taste my disaster" },
{ text: "It's heavy on my tongue" },
{ text: "All the lights aglow" },
{ text: "Tokyo snows" },
{ text: "Go to watch the show" },
{ text: "Curtain's closed" },
{ text: "I'm watching you this time" },
{ text: "And if the world don't break" },
{ text: "I'll be shaking it" },
{ text: "'Cause I'm a young man after all" },
{ text: "And when the seasons change" },
{ text: "Will you stand by me?" },
{ text: "'Cause I'm a young man built to fall" },
{ text: "New York City, it rains" },
{ text: "(Fly to East L.A.)" },
{ text: "In big jet planes" },
{ text: "You know you're on my mind?" },
{ text: "(All the lights aglow)" },
{ text: "Tokyo snows" },
{ text: "(Go to watch the show)" },
{ text: "Curtain's closed" },
{ text: "I'm watching you this time" },
{ text: "Mind over matter" },
{ text: "Mind over matter" },
{ text: "You know you're on my mind?" },
{ text: "And if the world don't break" },
{ text: "I'll be shaking it" },
{ text: "'Cause I'm a young man after all" },
{ text: "And when the seasons change" },
{ text: "Will you stand by me" },
{ text: "(Fly to East L.A.)" },
{ text: "'Cause I'm a young man built to fall" },
{ text: "And if the world don't break" },
{ text: "Tokyo snows" },
{ text: "Go to watch the show; curtain's closed" },
{ text: "And when the seasons change" },
{ text: "Will you stand by me?" },
{ text: "'Cause I'm a young man built to fall" }
    ];
    // === end lyrics block ===

    // default per-line duration (ms)
    const defaultDuration = 1200;

    const lyricsArea = document.getElementById('lyricsArea');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const speedInput = document.getElementById('speed');
    const durationDisplay = document.getElementById('durationDisplay');

    // build DOM lines
    lyrics.forEach((item, i) => {
      const div = document.createElement('div');
      div.className = 'line';
      // allow overriding duration per-line by adding data-duration (ms) to the object
      if (item.duration) div.dataset.duration = String(item.duration);
      // wrap text in a reveal span for karaoke effect
      const span = document.createElement('span');
      span.className = 'reveal';
      span.textContent = item.text;
      div.appendChild(span);
      lyricsArea.appendChild(div);
    });

    const lines = Array.from(document.querySelectorAll('.line'));
    let current = -1;
    let timer = null;
    let playing = false;

    function getLineDuration(lineEl){
      const dataset = lineEl.dataset.duration;
      if (dataset) {
        const n = Number(dataset);
        if (!Number.isNaN(n) && n > 50) return n;
      }
      return defaultDuration;
    }

    function highlightLine(index){
      lines.forEach((l, idx) => {
        l.classList.toggle('current', idx === index);
        // reset reveal pseudoelement width by forcing style change:
        const reveal = l.querySelector('.reveal');
        if (reveal){
          reveal.style.setProperty('--reveal-width','0%');
          // when activated add style to animate ::after
          if (idx === index){
            // compute duration and set the ::after width transition via inline CSS
            const d = getLineDuration(l);
            // set transition on pseudo element by animating a CSS custom property on the child
            // but since we can't style ::after directly here, we will set a timeout to update inline style for animation.
            // Technique: set the ::after width via setting style attribute on child element using transform: translateX? We'll instead use inline animation on ::after via style.sheet - simpler: set style attribute on reveal to trigger its ::after expansion via transition on width using element.style
            // We set a custom attribute style to force a small delay then set width to 100% via adding a class. Simpler:
            // Remove any inline width first:
            reveal.style.transition = "none";
            reveal.style.setProperty('--reveal-width','0%');
            // Force reflow
            void reveal.offsetWidth;
            // Now set transition to linear (duration)
            reveal.style.transition = `all ${d}ms linear`;
            // After next tick, set the ::after width by toggling a data attribute on the parent; CSS uses transition on reveal::after using width set via inline element style -> set a CSS variable on reveal for width
            reveal.style.setProperty('width','100%');
            // We'll set a small timeout to set the pseudo-element width through the element's style using a CSS variable that the ::after uses.
            reveal.style.setProperty('--after-width', '0%');
            // force reflow then set the CSS variable to 100%
            setTimeout(()=> {
              reveal.style.setProperty('--after-width','100%');
              // Also manipulate the actual pseudo-element by setting its inline style through a stylesheet would be required for perfect control.
            }, 10);
          } else {
            // clear any inline style
            reveal.style.transition = "";
            reveal.style.removeProperty('width');
            reveal.style.removeProperty('--after-width');
          }
        }
      });

      // scroll into view center the current line inside the lyrics area
      if (lines[index]){
        const containerRect = lyricsArea.getBoundingClientRect();
        const lineRect = lines[index].getBoundingClientRect();
        const offset = (lineRect.top + lineRect.bottom)/2 - (containerRect.top + containerRect.bottom)/2;
        lyricsArea.scrollBy({ top: offset, behavior: 'smooth' });
      }
    }

    function stepForward(){
      // move to next line, stop if end
      current++;
      if (current >= lines.length){
        // loop back to start
        current = 0;
      }
      highlightLine(current);
      const duration = getLineDuration(lines[current]);
      // set a timer to advance
      timer = setTimeout(() => {
        if (playing) stepForward();
      }, duration / Number(speedInput.value));
    }

    function play(){
      if (playing) return;
      playing = true;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      // if nothing shown, start from first line
      if (current === -1) {
        current = 0;
        highlightLine(current);
        timer = setTimeout(() => { if (playing) stepForward(); }, getLineDuration(lines[current]) / Number(speedInput.value));
      } else {
        // resume stepping
        timer = setTimeout(() => { if (playing) stepForward(); }, getLineDuration(lines[current]) / Number(speedInput.value));
      }
    }

    function pause(){
      playing = false;
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      if (timer) { clearTimeout(timer); timer = null; }
    }

    // initial UI state
    pauseBtn.disabled = true;
    durationDisplay.textContent = (defaultDuration/1000).toFixed(2) + 's';

    // wire up events
    playBtn.addEventListener('click', () => { play(); });
    pauseBtn.addEventListener('click', () => { pause(); });

    // speed control
    speedInput.addEventListener('input', () => {
      const speed = Number(speedInput.value);
      // display effective per-line time (for default)
      durationDisplay.textContent = (defaultDuration / 1000 / speed).toFixed(2) + 's';
      // if playing, restart the timer with new speed:
      if (playing){
        if (timer) { clearTimeout(timer); timer = null; }
        // schedule next step according to remaining of current line: for simplicity we restart full duration for current line at new speed
        timer = setTimeout(() => { if (playing) stepForward(); }, getLineDuration(lines[current]) / speed);
      }
    });

    // keyboard shortcuts: space toggles play/pause
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space'){
        e.preventDefault();
        if (playing) pause(); else play();
      } else if (e.key === 'ArrowRight'){
        // skip to next
        if (timer) clearTimeout(timer);
        stepForward();
      } else if (e.key === 'ArrowLeft'){
        // previous
        if (timer) clearTimeout(timer);
        current = Math.max(0, current-2); // stepForward will increment by 1
        stepForward();
      }
    });

    // accessibility: let user click a line to jump to it
    lines.forEach((l, idx) => {
      l.tabIndex = 0;
      l.setAttribute('role','button');
      l.addEventListener('click', () => {
        if (timer) clearTimeout(timer);
        current = idx - 1; // stepForward increments first
        stepForward();
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
      });
      l.addEventListener('keypress', (ev) => {
        if (ev.key === 'Enter' || ev.key === ' ') {
          ev.preventDefault();
          l.click();
        }
      });
    });

    // make the reveal pseudo-element CSS dynamic by injecting a small style block
    (function injectRevealStyle(){
      const style = document.createElement('style');
      style.textContent = `
        .line .reveal::after {
          content: "";
          position: absolute;
          left: 0; top: 0; height: 100%;
          background: linear-gradient(90deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.06) 50%, rgba(255,255,255,0.02) 100%);
          width: 0%;
          pointer-events: none;
          transition: width 800ms linear;
        }
        .line.current .reveal::after {
          /* when current, transition is updated dynamically from JS by adjusting inline style on child if needed */
        }
      `;
      document.head.appendChild(style);
    })();

    // override default transition duration for reveal element when a line becomes current
    // We'll observe class changes to set the correct transition duration on the ::after via inline style on the reveal element.
    const observer = new MutationObserver((entries) => {
      entries.forEach(mutation => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const target = mutation.target;
          if (target.classList.contains('current')) {
            const d = getLineDuration(target);
            const reveal = target.querySelector('.reveal');
            if (reveal){
              // set transition on ::after by setting a CSS variable we used in injected style? Simpler: create a tiny style element scoped to this element
              reveal.style.setProperty('transition-duration', `${d}ms`);
              // and set the ::after transition inline by adding a temporary style attribute on the element
              reveal.style.transition = `all ${d}ms linear`;
              // now animate width to full (so ::after expands)
              // a small timeout to allow the class addition to take effect
              setTimeout(() => {
                // set the pseudo-element width by toggling a data attribute that our injected CSS won't read; instead we animate by changing a background-size hack.
                // Simpler approach: animate the pseudo-element by adjusting a CSS variable on the element which is used by the pseudo-element (we didn't use variable initially). Let's set the pseudo-element width by adding an inline style on the element that the pseudo-element reads using attr() is not available. To keep it robust across browsers, we instead animate by inserting a tiny child overlay to mimic the ::after and animate its width.
                // However to keep it simple and reliable, we'll animate the reveal element's background using a linear-gradient and background-size. This visually approximates the reveal.
                reveal.style.backgroundImage = 'linear-gradient(90deg, rgba(255,255,255,0.00) 0%, rgba(255,255,255,0.03) 30%, rgba(255,255,255,0.00) 100%)';
                reveal.style.backgroundSize = '0% 100%';
                reveal.style.backgroundRepeat = 'no-repeat';
                reveal.style.transition = `background-size ${d}ms linear`;
                // trigger expansion
                setTimeout(()=> reveal.style.backgroundSize = '100% 100%', 20);
              }, 20);
            }
          } else {
            // not current: clear styles
            const reveal = mutation.target.querySelector('.reveal');
            if (reveal){
              reveal.style.backgroundImage = '';
              reveal.style.backgroundSize = '';
              reveal.style.transition = '';
              reveal.style.removeProperty('transition');
            }
          }
        }
      });
    });

    lines.forEach(l => observer.observe(l, { attributes: true }));

    // Optional: autostart
    // play();

    // expose a small API on window for debugging/customization
    window.lyricsPlayer = {
      play, pause, stepForward, lines, setDefaultDuration(ms){ defaultDuration = ms; durationDisplay.textContent = (ms/1000).toFixed(2)+'s'; }
    };
  </script>
</body>
</html>
